# Bubbli â€” Implementation Plan

## Vision

A privacy-first social media platform focused on connecting friends and family. Users control exactly who sees their content through **Circles** (visibility groups). The platform supports groups, cross-posting, and real-time updates. Designed API-first to support a web app now and native mobile apps in the future.

---

## Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   React SPA (Vite)  â”‚â—„â”€â”€â”€â”€â”€â–ºâ”‚  Phoenix API (JSON:API + RPC)    â”‚
â”‚   port 5173 (dev)   â”‚  WS   â”‚  port 4000                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚                                  â”‚
                              â”‚  Ash Resources                   â”‚
         Caddy (dev)          â”‚  AshJsonApi (REST)               â”‚
    local.bubbli.org          â”‚  AshAuthentication (magic link)  â”‚
    /* â†’ :5173                â”‚  Phoenix Channels (real-time)    â”‚
    /api/* â†’ :4000            â”‚  OpenAPI spec (auto-generated)   â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                         â”‚
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚  PostgreSQL (via AshPostgres)    â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚  S3 (media uploads, audit logs)  â”‚
                              â”‚  (deferred)                      â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Technology Choices

| Layer          | Technology                       | Rationale                                                              |
| -------------- | -------------------------------- | ---------------------------------------------------------------------- |
| Backend        | Elixir + Phoenix                 | Real-time, fault-tolerant, great developer experience                  |
| Data framework | Ash                              | Declarative resources, built-in authz, JSON:API for free               |
| Database       | PostgreSQL via AshPostgres       | Rock-solid relational DB, good JSON support                            |
| API style      | JSON:API (REST) + JSON-RPC       | JSON:API auto-generated by Ash; RPC for non-CRUD actions               |
| API contract   | OpenAPI 3.0 (via open_api_spex)  | Auto-generated spec â†’ typed React client via codegen                   |
| Auth           | AshAuthentication (magic link)   | Passwordless, secure, no password storage                              |
| Real-time      | Phoenix Channels (WebSocket)     | Native Phoenix capability, feeds into React via WS client              |
| Frontend       | React + Vite + TypeScript        | Large ecosystem, future code sharing with React Native for mobile      |
| Dev proxy      | Caddy                            | TLS termination, clean routing between frontend and API in development |
| Object storage | S3-compatible (deferred)         | Media uploads and audit log storage                                    |

### Why Not LiveView?

We need an API layer for future mobile apps. Building LiveView now would mean reimplementing the API later and maintaining two interface strategies. Phoenix Channels give us the same real-time PubSub capability that LiveView uses under the hood, but exposed as a generic WebSocket API consumable by any client (React, React Native, etc).

### Frontend Tech Stack

| Concern            | Tool                               | Why                                                        |
| ------------------ | ---------------------------------- | ---------------------------------------------------------- |
| Server state       | TanStack Query v5                  | Caching, pagination, optimistic updates for social data    |
| Client state       | React native (useState/useContext)  | Minimal client state in a social app                       |
| Routing            | TanStack Router v1 (file-based)    | Type-safe routes, deep Query integration, route loaders    |
| API client         | openapi-fetch + openapi-typescript | Auto-typed from Phoenix OpenAPI spec, zero handwritten fetch |
| Build              | Vite 6                             | Fast, reliable, great DX                                   |
| Type checking      | TypeScript (strict)                | Catches bugs, pairs perfectly with codegen                 |
| Linting/formatting | Biome                              | Single tool, fast, replaces ESLint + Prettier              |
| CSS                | Tailwind v4 (Vite plugin)          | Utility-first, fast iteration, no config file needed       |
| Testing (future)   | Playwright                         | E2E testing, deferred but planned                          |

**Key frontend principles:**
- No Redux, no Zustand â€” React's built-in state for UI concerns, TanStack Query for everything server-related
- API client is 100% generated from the OpenAPI spec â€” no handwritten fetch calls
- File-based routing with auto-generated type-safe route tree
- Dev tools for both Query and Router included in dev builds only

---

## Data Model

### Entity Relationship Overview

```
User
 â”œâ”€â”€ has many Connections (mutual, through join)
 â”œâ”€â”€ has many Circles (owns)
 â”‚    â””â”€â”€ has many CircleMembers (users in the circle)
 â”œâ”€â”€ has many Posts (authored)
 â”œâ”€â”€ has many Comments (authored)
 â”œâ”€â”€ has many Reactions (authored)
 â”œâ”€â”€ has many GroupMemberships
 â”‚    â””â”€â”€ belongs to Group
 â””â”€â”€ has many Notifications (recipient)

Post
 â”œâ”€â”€ belongs to User (author)
 â”œâ”€â”€ has many PostPlacements
 â”‚    â””â”€â”€ polymorphic target: Circle | Group
 â”œâ”€â”€ has many Comments
 â”œâ”€â”€ has many Reactions
 â””â”€â”€ optional: shared_post_id (self-ref, for future repost/share)

Group
 â”œâ”€â”€ has many GroupMemberships
 â”‚    â””â”€â”€ has role: admin | member
 â””â”€â”€ has visibility: public | request | private
```

### Resource Details

#### User

| Field             | Type     | Notes                                           |
| ----------------- | -------- | ----------------------------------------------- |
| id                | uuid     | PK                                              |
| email             | string   | Unique, used for magic link auth                |
| display_name      | string   | Shown publicly                                  |
| handle            | string   | Unique, @-mentionable                           |
| avatar_url        | string   | Nullable, URL to S3 (deferred)                  |
| bio               | string   | Nullable, short user bio                        |
| privacy_settings  | map/json | Controls profile visibility to non-connections  |
| inserted_at       | datetime |                                                 |
| updated_at        | datetime |                                                 |

Privacy settings (JSON, with defaults):
- `profile_visible_to`: `"connections_only"` | `"public"` â€” default `"connections_only"`
- `comment_visibility`: `"connections_and_group_members"` | `"everyone_on_post"` â€” default `"connections_and_group_members"`

#### Connection

Mutual friendship model. A connection is created when User A requests and User B accepts.

| Field        | Type     | Notes                              |
| ------------ | -------- | ---------------------------------- |
| id           | uuid     | PK                                 |
| requester_id | uuid     | FK â†’ User                          |
| receiver_id  | uuid     | FK â†’ User                          |
| status       | enum     | `pending`, `accepted`, `rejected`  |
| inserted_at  | datetime |                                    |
| updated_at   | datetime |                                    |

Constraints:
- Unique index on `{requester_id, receiver_id}` (ordered pair to prevent duplicates)
- Future consideration: asymmetric follow for public posts (separate `Follow` resource)

#### Block (schema only â€” implementation deferred)

| Field       | Type     | Notes    |
| ----------- | -------- | -------- |
| id          | uuid     | PK       |
| blocker_id  | uuid     | FK â†’ User|
| blocked_id  | uuid     | FK â†’ User|
| inserted_at | datetime |          |

#### Circle

A visibility circle. Every user gets three system circles on registration. Users can create custom circles.

| Field       | Type     | Notes                              |
| ----------- | -------- | ---------------------------------- |
| id          | uuid     | PK                                 |
| owner_id    | uuid     | FK â†’ User                          |
| name        | string   | e.g. "Close Friends", "Family"     |
| type        | enum     | `system`, `custom`                 |
| system_type | enum     | `private`, `all_friends`, `public` (null for custom) |
| description | string   | Nullable                           |
| inserted_at | datetime |                                    |
| updated_at  | datetime |                                    |

System circles (auto-created per user, non-deletable):
1. **Private** â€” only the author can see (system_type: `private`)
2. **All Friends** â€” all accepted connections (system_type: `all_friends`, membership is implicit/dynamic)
3. **Public** â€” anyone, including non-users (system_type: `public`)

#### CircleMember

Explicit membership in a custom circle. System circles (`all_friends`, `public`, `private`) don't use this table â€” their membership is computed.

| Field       | Type     | Notes        |
| ----------- | -------- | ------------ |
| id          | uuid     | PK           |
| circle_id   | uuid     | FK â†’ Circle  |
| user_id     | uuid     | FK â†’ User (the connection/friend being added) |
| inserted_at | datetime |              |

Constraints:
- Unique on `{circle_id, user_id}`
- The `user_id` must be an accepted connection of the circle's owner

#### Post

| Field           | Type     | Notes                                      |
| --------------- | -------- | ------------------------------------------ |
| id              | uuid     | PK                                         |
| author_id       | uuid     | FK â†’ User                                  |
| content         | string   | Max 4000 characters                        |
| shared_post_id  | uuid     | Nullable, FK â†’ Post (for future reposting) |
| edited_at       | datetime | Nullable, set on edit                      |
| inserted_at     | datetime |                                             |
| updated_at      | datetime |                                             |

On edit: `edited_at` is updated. An async job writes the previous content to S3 at `posts/{author_id}/{post_id}/{timestamp}.json`.

On delete: hard delete from DB. An async job writes a tombstone record to S3 with the final content, deletion timestamp, and actor.

#### PostPlacement

Where a post is visible. A post can be placed in multiple circles and/or groups simultaneously.

| Field       | Type     | Notes                                   |
| ----------- | -------- | --------------------------------------- |
| id          | uuid     | PK                                      |
| post_id     | uuid     | FK â†’ Post                               |
| target_type | string   | `"circle"` or `"group"`                 |
| target_id   | uuid     | FK â†’ Circle or Group (polymorphic)      |
| inserted_at | datetime |                                         |

Constraints:
- Unique on `{post_id, target_type, target_id}`

**How visibility works:**
- When creating a post, the user selects one or more targets (circles and/or groups)
- Default: the user's "All Friends" system circle
- The feed query collects all posts where the viewer has access through any placement target:
  - Circle placement: viewer is the owner (Private), viewer is an accepted connection (All Friends), viewer is a CircleMember (custom), or it's Public
  - Group placement: viewer is a GroupMember of that group
- Cross-posted content: the post appears once in the feed, with an indicator showing all groups/circles it was shared to (that the viewer has access to)

#### Comment

Flat comments initially. Future: add `parent_comment_id` for threading.

| Field       | Type     | Notes     |
| ----------- | -------- | --------- |
| id          | uuid     | PK        |
| post_id     | uuid     | FK â†’ Post |
| author_id   | uuid     | FK â†’ User |
| content     | string   | Max 2000 characters |
| inserted_at | datetime |           |
| updated_at  | datetime |           |

Visibility: comments inherit post visibility. All viewers of the post see all comments. However, the **commenter's profile information** shown to each viewer depends on their relationship:
- If the viewer is a connection of the commenter â†’ full profile
- If not â†’ limited profile (display_name and avatar only), controlled by commenter's `privacy_settings`

#### Reaction

Polymorphic â€” can react to both posts and comments.

| Field          | Type     | Notes                          |
| -------------- | -------- | ------------------------------ |
| id             | uuid     | PK                             |
| user_id        | uuid     | FK â†’ User                      |
| reactable_type | string   | `"post"` or `"comment"`        |
| reactable_id   | uuid     | FK â†’ Post or Comment           |
| emoji          | string   | One of the allowed set         |
| inserted_at    | datetime |                                |

Default reaction set: `â¤ï¸` `ğŸ˜‚` `ğŸ˜®` `ğŸ˜¢` `ğŸ˜¡` `ğŸ‘`

Constraints:
- Unique on `{user_id, reactable_type, reactable_id}` â€” one reaction per user per target
- User can change their reaction but not add multiple

#### Group

| Field       | Type     | Notes                                              |
| ----------- | -------- | -------------------------------------------------- |
| id          | uuid     | PK                                                 |
| name        | string   |                                                    |
| description | string   | Nullable                                           |
| visibility  | enum     | `public`, `request`, `private`                     |
| avatar_url  | string   | Nullable                                           |
| created_by  | uuid     | FK â†’ User (becomes first admin)                    |
| inserted_at | datetime |                                                    |
| updated_at  | datetime |                                                    |

Visibility meanings:
- `public` â€” anyone can join, group is discoverable
- `request` â€” group is discoverable, membership requires admin approval
- `private` â€” invite only, not discoverable in search

#### GroupMembership

| Field       | Type     | Notes                    |
| ----------- | -------- | ------------------------ |
| id          | uuid     | PK                       |
| group_id    | uuid     | FK â†’ Group               |
| user_id     | uuid     | FK â†’ User                |
| role        | enum     | `admin`, `member`        |
| status      | enum     | `active`, `pending`, `invited` |
| inserted_at | datetime |                          |
| updated_at  | datetime |                          |

Constraints:
- Unique on `{group_id, user_id}`
- The group creator is auto-added as `admin` with `active` status

#### Notification

In-app notifications. Push/email delivery deferred but the schema supports it.

| Field        | Type     | Notes                                           |
| ------------ | -------- | ----------------------------------------------- |
| id           | uuid     | PK                                              |
| recipient_id | uuid     | FK â†’ User                                       |
| actor_id     | uuid     | FK â†’ User (who triggered it)                    |
| type         | string   | `friend_request`, `friend_accepted`, `comment`, `reaction`, `group_invite`, `group_request`, `post_mention` |
| target_type  | string   | `"post"`, `"comment"`, `"group"`, `"connection"` |
| target_id    | uuid     | FK to the relevant entity                       |
| read_at      | datetime | Nullable, null = unread                         |
| inserted_at  | datetime |                                                 |

---

## Post Sharing / Reposting (Future Feature)

When implemented, a shared post is just a new Post with:
- `shared_post_id` pointing to the original
- Its own `content` (the sharer's added commentary)
- Its own `PostPlacements` (the sharer's chosen visibility)

The original post's content is embedded when rendering, but visibility of the **original** content respects the original author's placements. If the viewer can't see the original post through its placements, they see a "this post is not available" placeholder. This prevents visibility escalation.

---

## Audit Log Strategy (S3-based)

Rather than storing audit logs in PostgreSQL, we ship them to S3 asynchronously.

**Structure:**
```
audit/
  posts/{user_id}/{post_id}/
    {iso_timestamp}_edit.json     â† content before edit
    {iso_timestamp}_delete.json   â† content at time of deletion + metadata
  comments/{user_id}/{comment_id}/
    {iso_timestamp}_edit.json
    {iso_timestamp}_delete.json
```

**Implementation:**
- A GenServer-based audit writer with a buffered flush (e.g., every 5s or 100 items)
- Or Broadway for higher throughput later
- Each audit entry is a JSON blob: `{actor_id, action, timestamp, previous_content, metadata}`
- Deferred until S3 integration is set up; for now, log to Logger at `:info` level as a placeholder

---

## API Design

### JSON:API Endpoints (auto-generated by AshJsonApi)

These follow the [JSON:API spec](https://jsonapi.org/) and are auto-generated from Ash resource definitions.

```
# Auth
POST   /api/auth/magic-link/request    â† JSON-RPC: request magic link email
POST   /api/auth/magic-link/callback   â† JSON-RPC: exchange token for session
POST   /api/auth/sign-out              â† JSON-RPC: end session
GET    /api/auth/me                    â† current user

# Users
GET    /api/users/:id                  â† public profile (filtered by privacy)
PATCH  /api/users/:id                  â† update own profile

# Connections
GET    /api/connections                â† list my connections (accepted)
GET    /api/connections/pending        â† pending requests
POST   /api/connections                â† send friend request
PATCH  /api/connections/:id            â† accept/reject
DELETE /api/connections/:id            â† remove connection

# Circles
GET    /api/circles                    â† list my circles
POST   /api/circles                    â† create custom circle
PATCH  /api/circles/:id               â† update circle
DELETE /api/circles/:id               â† delete custom circle (not system)
GET    /api/circles/:id/members        â† list members
POST   /api/circles/:id/members        â† add member
DELETE /api/circles/:id/members/:uid   â† remove member

# Posts
GET    /api/feed                       â† aggregated feed (posts I can see)
POST   /api/posts                      â† create post (with placements)
GET    /api/posts/:id                  â† single post
PATCH  /api/posts/:id                  â† edit post
DELETE /api/posts/:id                  â† delete post

# Comments
GET    /api/posts/:id/comments         â† list comments on post
POST   /api/posts/:id/comments         â† add comment
PATCH  /api/comments/:id              â† edit comment
DELETE /api/comments/:id              â† delete comment

# Reactions
POST   /api/reactions                  â† add/change reaction
DELETE /api/reactions/:id              â† remove reaction

# Groups
GET    /api/groups                     â† list my groups + discoverable groups
POST   /api/groups                     â† create group
GET    /api/groups/:id                 â† group detail
PATCH  /api/groups/:id                â† update group (admin)
DELETE /api/groups/:id                â† delete group (admin)
GET    /api/groups/:id/feed            â† posts in group
GET    /api/groups/:id/members         â† list members
POST   /api/groups/:id/join            â† JSON-RPC: join/request
POST   /api/groups/:id/invite          â† JSON-RPC: invite user (admin)
PATCH  /api/groups/:id/members/:uid    â† update role/approve (admin)
DELETE /api/groups/:id/members/:uid    â† remove/leave

# Notifications
GET    /api/notifications              â† list notifications
POST   /api/notifications/read         â† JSON-RPC: mark as read (batch)

# OpenAPI
GET    /api/openapi                    â† OpenAPI 3.0 spec (JSON)
```

### Real-Time (Phoenix Channels)

```
Channel: "user:{user_id}"
  Events:
    - new_notification
    - connection_request
    - connection_accepted

Channel: "feed:{user_id}"
  Events:
    - new_post          â† post visible to this user was created
    - post_updated      â† post was edited
    - post_deleted      â† post was removed

Channel: "post:{post_id}"
  Events:
    - new_comment
    - comment_updated
    - comment_deleted
    - new_reaction
    - reaction_removed

Channel: "group:{group_id}"
  Events:
    - new_post
    - member_joined
    - member_left
```

The viewer joins channels based on what they're looking at. The server broadcasts after Ash actions via PubSub. Authorization is checked at channel join time.

### OpenAPI â†’ Client Codegen

1. Phoenix serves the OpenAPI spec at `/api/openapi`
2. `openapi-typescript` generates TypeScript types from the spec
3. `openapi-fetch` provides a typed fetch client using those types
4. A single `npm run generate-api` command regenerates the client after backend changes
5. Zero handwritten fetch code â€” API changes automatically propagate to the frontend

---

## Implementation Phases

### Phase 0: Project Scaffolding âœ…

- [x] Generate Phoenix project (--no-html --no-live)
- [x] Remove esbuild/tailwind/heroicons (React/Vite handles frontend)
- [x] Configure Caddy for dev proxy
- [x] Install Ash packages (`ash`, `ash_postgres`, `ash_json_api`, `ash_authentication`)
- [x] Install supporting packages (`cors_plug`, `open_api_spex`)
- [x] Configure AshPostgres (replace Ecto.Repo with AshPostgres.Repo)
- [x] Configure CORS for development (CORSPlug in endpoint)
- [x] Configure JSON:API router (AshJsonApiRouter with Accounts domain)
- [x] Set up OpenAPI spec endpoint (`/api/open_api` + SwaggerUI at `/api/swaggerui`)
- [x] Create database, verify migration pipeline works
- [x] Set up React app with Vite + TypeScript in `web/`
- [x] Configure OpenAPI client codegen (`bun run generate-api` against live backend)
- [x] Verify full stack: React â†’ Caddy â†’ Phoenix â†’ Postgres round-trip

### Phase 1: Auth & Users (nearly complete)

- [x] Define `Bubbli.Accounts.User` Ash resource (email, display_name, handle, bio, avatar_url, profile_visibility, comment_visibility)
- [x] Configure AshAuthentication magic link strategy (with email sender)
- [x] Token-based API auth (Bearer tokens via `AshAuthentication.Plug.Helpers.retrieve_from_bearer`)
- [x] Auth controller routes (request magic link, callback, sign-out, me) at `/api/auth/*`
- [x] JSON:API routes for users (index, get, update_profile) auto-generated
- [x] Policies: unauthenticated access for auth actions, read for all, update_profile for self only
- [x] System circle creation on user registration (Ash change on `sign_in_with_magic_link`)
- [x] React: auth flow (request magic link â†’ check email â†’ token stored â†’ authenticated)
- [x] React: basic app shell, routing, auth context
- [x] React: user profile view/edit

### Phase 2: Connections

- [x] Define `Bubbli.Social.Connection` Ash resource
- [x] Actions: `send_request`, `accept`, `reject`, `remove`
- [x] Validation: prevent duplicate/self-connections
- [x] JSON:API routes for connections
- [x] React: user search / discovery (by handle or display name)
- [ ] Notifications on friend request and acceptance
- [ ] Phoenix Channel: broadcast connection events
- [ ] React: connection management (send/accept/reject requests, list friends)

### Phase 3: Circles

- [x] Define `Bubbli.Social.Circle` Ash resource
- [x] Define `Bubbli.Social.CircleMember` Ash resource
- [x] System circle seeding on user creation (hook from Phase 1)
- [x] Prevent deletion of system circles
- [ ] Custom circle CRUD
- [ ] Circle member management (add/remove connections)
- [ ] View which circles a connection is in (from connection page)
- [ ] React: circle list, create/edit/delete custom circles
- [ ] React: manage circle membership
- [ ] React: connection page shows circle membership

### Phase 4: Posts & Feed

- [ ] Define `Bubbli.Content.Post` Ash resource (4k char limit)
- [ ] Define `Bubbli.Content.PostPlacement` Ash resource
- [ ] Post creation with multi-target placement selection
- [ ] Post editing with `edited_at` timestamp
- [ ] Post deletion (hard delete)
- [ ] Audit log placeholder (Logger-based until S3 integration)
- [ ] Feed query: aggregate posts visible to current user
  - Through circle placements (system + custom circle membership)
  - Through group placements (group membership)
  - Deduplicate cross-posted content
- [ ] Define `Bubbli.Content.Comment` Ash resource (flat)
- [ ] Define `Bubbli.Content.Reaction` Ash resource (polymorphic)
- [ ] Reaction set enforcement (only allowed emojis)
- [ ] One reaction per user per target
- [ ] Profile information filtering on comments (privacy-aware serialization)
- [ ] Phoenix Channels: `feed:{user_id}`, `post:{post_id}` with real-time events
- [ ] React: feed view with infinite scroll
- [ ] React: post creation with circle/group target picker
- [ ] React: post detail with comments and reactions
- [ ] Phoenix Channel: `user:{user_id}` with token auth
- [ ] React: real-time feed and comment updates via WebSocket

### Phase 5: Groups

- [ ] Define `Bubbli.Social.Group` Ash resource
- [ ] Define `Bubbli.Social.GroupMembership` Ash resource
- [ ] Group creation (creator becomes admin)
- [ ] Visibility modes: public (auto-join), request (needs approval), private (invite-only)
- [ ] Join, request, and invite flows
- [ ] Admin actions: approve requests, remove members, update group
- [ ] Integrate groups into PostPlacement (post to groups)
- [ ] Group feed (posts placed in this group)
- [ ] Cross-group posting: post visible in multiple groups, unified comment thread
- [ ] Cross-group posting: UI indicator showing "shared in Group A and Group B"
- [ ] Phoenix Channel: `group:{group_id}` with real-time events
- [ ] React: group browsing / discovery
- [ ] React: group detail, member list, management (admin)
- [ ] React: group feed
- [ ] React: post creation with group targeting

### Phase 6: Notifications & Polish

- [ ] Define `Bubbli.Notifications.Notification` Ash resource
- [ ] Generate notifications from Ash action hooks (friend request, comment, reaction, group invite, etc.)
- [ ] Mark as read (individual and batch)
- [ ] Real-time notification delivery via `user:{user_id}` channel
- [ ] React: notification bell / panel
- [ ] Profile privacy controls UI
- [ ] Rate limiting on API endpoints
- [ ] Input sanitization and abuse prevention
- [ ] Search (users by handle/name, groups by name)

### Phase 7: Media & Audit (deferred)

- [ ] S3 integration (ExAws or similar)
- [ ] Direct-to-S3 upload with presigned URLs
- [ ] Image/video attachments on posts
- [ ] Avatar uploads for users and groups
- [ ] Audit log writer (GenServer â†’ S3)
- [ ] Migrate audit logging from Logger to S3

### Phase 8: Mobile Readiness (deferred)

- [ ] API documentation and hardening
- [ ] Token refresh / long-lived session strategy for mobile
- [ ] Push notification infrastructure (APNs / FCM)
- [ ] React Native project sharing data layer with web
- [ ] Offline-first considerations (if needed)

---

## Current Project State

### What exists

- Phoenix 1.8.3 project generated with `--no-html --no-live --no-dashboard`
- Elixir 1.19 / Erlang OTP 28
- PostgreSQL configured and running with all migrations applied
- Mailer configured (Swoosh, local adapter for dev)
- Caddy reverse proxy configured for dev (handle blocks for correct routing)
- esbuild/tailwind/heroicons removed (React/Vite will handle frontend)
- React web app with Vite + TanStack Router + TanStack Query in `web/`
- Ash 3.15 installed with AshPostgres, AshJsonApi, AshAuthentication
- `Bubbli.Accounts` domain with User and Token resources
- `Bubbli.Social` domain with Circle and CircleMember resources
- Magic link auth strategy fully working (request â†’ email â†’ token exchange â†’ JWT)
- Auth controller at `/api/auth/*` (request, callback, me, sign-out)
- JSON:API endpoints at `/api/users` and `/api/circles` (auto-generated)
- OpenAPI spec at `/api/open_api`, SwaggerUI at `/api/swaggerui`
- OpenAPI â†’ TypeScript codegen working (`bun run generate-api`)
- Typed `openapi-fetch` client with auth middleware (`src/api/client.ts`)
- Auth API module for custom auth endpoints (`src/api/auth.ts`)
- Auth context with token storage, `/me` query, login/logout (`src/lib/auth.tsx`)
- React auth flow: login â†’ magic link email â†’ callback route â†’ token exchange â†’ redirect
- React routes: `/`, `/login`, `/profile`, `/auth/magic-link/callback`
- Profile page with view/edit mode (updates via JSON:API PATCH)
- System circles (Private, All Friends, Public) auto-created on first user registration
- CORSPlug configured in endpoint
- Biome linting/formatting configured and passing
- Clean compile, zero warnings, all tests passing

### What's next (immediate)

1. Verify full round-trip: React â†’ Caddy â†’ Phoenix â†’ Postgres (manual test)
2. Complete remaining Phase 1: Phoenix Channel `user:{user_id}` with token auth
3. Begin Phase 2 (Connections): define `Bubbli.Social.Connection` resource
4. Continue Phase 3: custom circle CRUD, circle member management, React UI
5. Build React connection management UI (send/accept/reject, list friends)

---

## Ash Domain Organization

```
Bubbli.Accounts      â† User, Token (auth)
Bubbli.Social        â† Connection, Block, Circle, CircleMember, Group, GroupMembership
Bubbli.Content       â† Post, PostPlacement, Comment, Reaction
Bubbli.Notifications â† Notification
```

Each domain gets its own Ash domain module and groups related resources.

---

## Open Questions & Future Considerations

1. **Asymmetric following** â€” Currently connections are mutual. May want to add a separate `Follow` resource later for following public users without a mutual connection.
2. **Post sharing/reposting** â€” `shared_post_id` is in the schema but implementation is deferred. Key challenge is visibility escalation prevention.
3. **Comment threading** â€” Starting flat. Adding `parent_comment_id` later for nesting. UI can render nested without schema changes if we add depth limits.
4. **Media types on posts** â€” Will need a `PostMedia` join table or embedded schema for multiple attachments per post (images, videos, links).
5. **Link previews / embeds** â€” Likely an async job that fetches Open Graph metadata when a URL is detected in post content.
6. **Search** â€” PostgreSQL full-text search is likely sufficient initially. May graduate to Elasticsearch/Meilisearch if needed.
7. **Rate limiting** â€” Consider `hammer` or `ex_rated` for API rate limiting.
8. **Events** â€” Deferred entirely. Would be its own domain (`Bubbli.Events`) with Event, EventRSVP resources, integrated with Groups and Circles for visibility.
